import math

# 컬렉션과 반복문

students = [("철수", 85), ("영희", 55), ("민수", 72), ("지영", 40)]

for name, score in students:
    if score >= 60:
        print(name, "합격 🎉")
    else:
        print(name, "불합격 😢")

학생성적표 = {
    "김철수": 90,
    "김영희": 80,
    "김민수": 100,
    "박철수": 50,
    "박영희": 45,
}

# 학생들의 평균점수 구하기
총합 = 0
for 점수 in 학생성적표.values():
    총합 += 점수

평균점수 = 총합 / len(학생성적표)
print(평균점수)

# 60점 이상 학생들의 평균점수(반복문안에 if문 사용)

총합 = 0
육십점이상사람수 = 0
for 점수 in 학생성적표.values():
    if 점수 >= 60:
        총합 += 점수
        육십점이상사람수 += 1

평균점수 = 총합 / 육십점이상사람수
print(평균점수)

김철수씨 = {
    "이름": "김철수",
    "나이": 30,
    "국적": "대한민국",
    "성별": "남자",
    "취미": ["코딩", "독서", "음악감상"],
}

# items() 사용 -> [(키, 값), (키, 값), ....(키, 값)] 의 형태로 만들어준다!
# for문에서 사용하면, 순서대로 튜플 언패킹!
for 키, 값 in 김철수씨.items():
    print(f"키:{키}, 값:{값}")

# 첫번째 반복: 키, 값 = ("이름", "김철수") 튜플 언패킹
# 두번째 반복: 키, 값 = ("나이", 30) 튜플 언패킹
# 세번째 반복: 키, 값 = ("국적", "대한민국") 튜플 언패킹

전화번호부 = {
    "김철수": "010-1111-1111",
    "박철수": "010-2222-2222",
    "이철수": "010-3333-3333",
    "김영희": "010-4444-4444",
    "박영희": "010-5555-5555",
    "이영희": "010-6666-6666",
}

# 010-5555-5555로 전화가 왔다. 반복문으로 전화번호부를 찾아보면서,
# 발신자의 이름이 무엇인지 print 해주세요

발신번호 = "010-5555-5555"
있는번호인가 = False

for 이름, 전화번호 in 전화번호부.items():
    if 발신번호 == 전화번호:
        print(이름)
        있는번호인가 = True
        break

if not 있는번호인가:
    print("발신자 알수없음")

# 철수의 위치(15, 20) 에서 가장 가까운 맛집
맛집데이터 = {
    (5, 10): "에드워드리 가게",
    (10, 20): "최현석 가게",
    (15, 30): "급식대가 가게",
    (20, 40): "나폴리 맛피아 가게",
    (25, 50): "철가방요리사 가게",
}

철수x, 철수y = (15, 20)
최소거리 = 99999999  # 큰수로 초기화 해줘야 비교가능
최소거리 = float("inf")  # 무한대로 초기화하는법
가까운맛집이름 = ""

for 좌표, 가게이름 in 맛집데이터.items():
    가게좌표x, 가게좌표y = 좌표
    계산한직선거리 = (철수x - 가게좌표x) ** 2 + (철수y - 가게좌표y) ** 2
    if 계산한직선거리 < 최소거리:
        최소거리 = 계산한직선거리  # 계산한직선거리가 최소거리보다 작구나! 이걸 최소거리로 갱신해줘야겠다
        가까운맛집이름 = 가게이름  # 지금 최소거리에 있는 가게이름을 넣어주자!

print(f"철수와 가장 가까운 맛집:{가까운맛집이름}, {math.sqrt(최소거리)}만큼 이동하면됩니다")
